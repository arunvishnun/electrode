/* eslint-disable @typescript-eslint/no-var-requires, max-statements */
/* eslint-disable no-process-exit */

import * as Fs from "fs";
import * as Path from "path";
import * as _ from "lodash";
const optionalRequire = require("optional-require")(require);
const chalk = require("chalk");
import { logger } from "@xarc/dev-base";
const mkdirp = require("mkdirp");
import { loadXarcOptions } from "../util/load-xarc-options";
import { injectEntry } from "../util/inject-entry";

const DEV_HMR_DIR = ".__dev_hmr";
const PROD_DIR = ".__prod__";

function createDirectoriesIfNeeded(isDev: boolean, appCwd: string, appMode: any) {
  const dir = Path.resolve(appCwd, appMode.src.dir, isDev ? DEV_HMR_DIR : PROD_DIR);
  const gitIgnoreFile = Path.join(dir, ".gitignore");

  if (!Fs.existsSync(gitIgnoreFile)) {
    mkdirp.sync(dir);
    Fs.writeFileSync(gitIgnoreFile, `# Directory to contain default hot module loaders for subapps
# Please ignore this
# Please don't commit this
*
`);
  }
  return dir;
}

function generateHmrString(req: string, subAppReducers: string | undefined): string {
  const reduxHmrString = subAppReducers ? `
import { getReduxCreateStore } from "subapp-redux";
import reducers from "${subAppReducers}";
if (subApp.reduxReducers && (!subApp.reduxCreateStore || subApp._genReduxCreateStore)) {
  subApp._genReduxCreateStore = "hmr";
  const createStore = getReduxCreateStore(subApp);
  subApp.reduxCreateStore = initialState => {
    const store = createStore(initialState);
    module.hot.accept("${subAppReducers}", () => {
      store.replaceReducer(require("${subAppReducers}").default, subApp);
    });
    return store;
  };
}` : '';

  return `
if (module.hot) {
  module.hot.accept("${req}", () => {
    require("subapp-web").hotReloadSubApp(require("${req}"));
  });
}
${reduxHmrString}
`;
}

function generateEntryFileContent(subAppReq: string, isBootstrapChunkNeeded: boolean, isDev: boolean, manifest: any): string {
  const importEntryWithoutBootstrapChunk = `import subApp from "${subAppReq}"`;
  const importEntryWithBootstrapChunk = `const subApp = import( /* webpackChunkName: "${manifest.name.replace(
    "/",
    "_"
  )}~._bootstrap__" */"${subAppReq}");`;

  const importStatement = isBootstrapChunkNeeded ? importEntryWithBootstrapChunk : importEntryWithoutBootstrapChunk;
  const subAppReducers = manifest.reducers ? (manifest.module ? manifest.reducers : `../${manifest.subAppDir}/reducers`) : undefined;
  const hmrString = isDev ? generateHmrString(subAppReq, subAppReducers) : "";

  return `
// generated by config/webpack/partial/entry.js
${importStatement}
export default subApp;
${hmrString}
`;
}

function genSubAppHmrEntry(hmrDir: string, isDev: boolean, manifest: any, appOptions: any): string {
  let subAppReq = manifest.module
    ? manifest.entry
    : `${manifest.subAppDir}/${manifest.entry}`;

  if (manifest.hmrSelfAccept) {
    return manifest.module ? subAppReq : `./${subAppReq}`;
  }

  const hmrEntry = `${isDev ? "hmr" : "prod"}-${manifest.subAppDir.replace(
    /[\/\\]/g,
    "-"
  )}.js`;
  subAppReq = manifest.module ? subAppReq : `../${subAppReq}`;

  const isBootstrapChunkNeeded = isDev ? true : appOptions.options.subappMode === "shell";

  const content = generateEntryFileContent(subAppReq, isBootstrapChunkNeeded, isDev, manifest);

  Fs.writeFileSync(Path.join(hmrDir, hmrEntry), content);

  return `./${isDev ? DEV_HMR_DIR : PROD_DIR}/${hmrEntry}`;
}

function createEntryContext(appOptions: any, partial: any) {
  const appCwd = appOptions.cwd;
  const appMode = appOptions.AppMode;
  partial.context = Path.resolve(appCwd, appMode.src.client);
}

function searchEntryConfig(partial: any) {
  const entryPath = Path.join(partial.context, "entry.config.js");

  const entry = optionalRequire(entryPath, {
    fail: (err) => {
      logger.error(`Loading ${entryPath} failed`, err);
      process.exit(1);
    },
    notFound: () => {
      // logger.info(`No custom entry point configuration ${entryPath}`);
    },
  });

  if (entry) {
    logger.info(`Using custom entry config from ${entryPath}`);
  }

  return entry;
}

function searchSubApps(appMode: any, isDev: boolean, appCwd: string, appOptions: any) {
  const subApps = appMode.subApps;

  if (_.isEmpty(subApps)) {
    return false;
  } else {
    logger.info(`Found version 1 subapps: ${Object.keys(subApps).join(", ")}`);
  }

  const hmrDir = createDirectoriesIfNeeded(isDev, appCwd, appMode);
  const entry = {};
  _.each(subApps, (ma) => {
    const entryName = `${ma.name.toLowerCase()}`;
    const x1 = `${chalk.magenta("subapp")} ${chalk.blue(ma.name)}`;
    entry[entryName] = genSubAppHmrEntry(hmrDir, isDev, ma, appOptions);
    logger.info(`${x1} entry ${entry[entryName]}`);
  });

  return entry;
}

function appEntry(appOptions: any, partial: any) {
  const entryConfig = searchEntryConfig(partial);
  if (entryConfig) return entryConfig;

  if (appOptions.options.subapp !== false) {
    const subApps = searchSubApps(appOptions.AppMode, Boolean(process.env.WEBPACK_DEV), appOptions.cwd, appOptions);
    if (subApps) {
      return subApps;
    }
  } else {
    logger.info(`subapp turned off by archetypeConfig.options.subapp flag`);
  }

  const entries = ["./app.js", "./app.jsx", "./app.tsx"];
  let entry = entries.find((f) =>
    Fs.existsSync(Path.join(partial.context, f))
  );

  if (!entry) {
    entry = entries.find((f) =>
      Fs.existsSync(Path.join(appOptions.AppMode.src.dir, f))
    );
    if (entry) {
      logger.info(
        `Found your app entry as ${entry} under dir ${appOptions.AppMode.src.dir} - setting webpack context to it.`
      );
      partial.context = Path.join(appOptions.cwd, appOptions.AppMode.src.dir);
      return entry;
    }

    entry = "./app.jsx";
    logger.info(
      `Unable to determine your app's entry - assuming it's ${entry} under dir ${partial.context}`
    );
  } else {
    logger.info(
      `Default to single app entry point using ${entry} under context ${partial.context}`
    );
  }

  return entry;
}

function shouldPolyfill(appOptions: any) {
  if (appOptions.webpack.enableBabelPolyfill) {
    const hasMultipleTarget =
      Object.keys(appOptions.babel.envTargets).sort().join(",") !==
      "default,node";
    if (hasMultipleTarget) {
      return appOptions.babel.target === "default";
    } else {
      return true;
    }
  }
  return false;
}

function makeEntry(appOptions: any, partial: any) {
  let entry = appEntry(appOptions, partial);
  const polyfill = shouldPolyfill(appOptions);

  const jsonpCdn =
    !process.env.WEBPACK_DEV &&
    require.resolve("../client/webpack5-jsonp-cdn");

  if (polyfill) {
    const coreJs = "core-js";
    const runtime = "regenerator-runtime/runtime";
    entry = injectEntry({ entry }, [jsonpCdn, coreJs, runtime]).entry;
  } else {
    entry = injectEntry({ entry }, jsonpCdn).entry;
  }

  return entry;
}

function makeEntryPartial() {
  const appOptions = loadXarcOptions();
  const partial: any = {};
  createEntryContext(appOptions, partial);

  partial.entry = makeEntry(appOptions, partial);

  return partial;
}

module.exports = makeEntryPartial;